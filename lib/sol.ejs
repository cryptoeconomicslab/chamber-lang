pragma solidity ^0.5.0;
pragma experimental ABIEncoderV2;

import {DataTypes as types} from "../DataTypes.sol";
import "../UniversalAdjudicationContract.sol";
import "./AtomicPredicate.sol";
import "./NotPredicate.sol";
<%
function getInputs(item, witnessName) {
  let str = ""
  if(item.dec.isCompiled) {
    str += item.dec.predicate + ', '
  }
  for(var k=0;k < item.dec.inputs.length;k++){
    if(item.dec.inputs[k] >= 0) {
      str += "_inputs[" + (item.dec.inputs[k] + 1) + "]"
    }else{
      str += witnessName || "challengeInput"
    }
    if(k < item.dec.inputs.length - 1) {
      str += ","
    }
  }
  return str
}
function isValidChallenge(predicate) {
  return (
    predicate == 'ForAllSuchThat' ||
    predicate == 'Not' ||
    predicate == 'And'
  )
}
%>

<%
  const headProperty = properties[properties.length - 1]
%>
/**
 * <%= headProperty.dec.predicate %>(<%= headProperty.dec.inputDefs %>)
 */
contract <%= headProperty.dec.predicate %> {
  <%
  for(var i = 0;i < properties.length;i++) {
    let property = properties[i]
  %>
    string public <%= property.dec.predicate %> = "<%= property.dec.predicate %>";
  <%
  }
  %>
    UniversalAdjudicationContract AdjudicationContract;
    AtomicPredicate SU;
    AtomicPredicate LessThan;
    AtomicPredicate eval;
    NotPredicate Not;
    constructor(address _adjudicationContractAddress) {
      AdjudicationContract = UniversalAdjudicationContract(_adjudicationContractAddress);
    }
    /**
    * @dev Validates a child node of the property in game tree.
    */
    function isValidChallenge(
        bytes[] memory _inputs,
        bytes memory _challengeInput,
        types.Property memory _challenge
    ) public returns (bool) {
        require(getChild(_inputs, _challengeInput) == keccak256(_challenge));
        return true;
    }

    function getChild(bytes[] memory inputs, bytes memory challengeInput) private returns (types.Property memory) {
      <%
      for(var i = 0;i < properties.length;i++) {
        let property = properties[i]
      %>
        if(inputs[0] == <%= property.dec.predicate %>) {
          return getChild<%= property.dec.predicate %>(inputs, challengeInput);
        }<%}%>
    }

  /**
   * @dev check the property is true
   */
  function decideTrue(bytes[] memory _inputs) public {
    <%
    for(var i = 0;i < properties.length;i++) {
      let property = properties[i]
    %>
    if(_inputs[0] == <%= property.dec.predicate %>) {
      decideTrue<%= property.dec.predicate %>(_inputs);
    }
    <%
    }
    %>
  }

  <%
  for(var i = 0;i < properties.length;i++) {
    let property = properties[i]
  %>
  <% if(isValidChallenge(property.statement.predicate)) { %>
    function getChild<%= property.dec.predicate %>(bytes[] memory _inputs, bytes memory challengeInput) private returns (types.Property memory) {
      <% if(property.statement.predicate == 'And') { %>
        <%
          for(var j = 0;j < property.statement.compiledChildren.length;j++) {
            var item = property.statement.compiledChildren[j]
        %>
        if(challengeInput == <%= j %>) {
          return type.Property({
            predicate: Not,
            inputs: [{
              predicate: <%= item.dec.originalPredicateName %>,
              inputs: [<%=getInputs(item)%>],
            }]
          });
        }
        <% } %>
      <% } else if(property.statement.predicate == 'ForAllSuchThat') {
        const quantifier = property.statement.compiledChildren[0];
        const innerProperty = property.statement.compiledChildren[2];
        %>
      require(<%= quantifier.dec.predicate %>.decide(<%=getInputs(quantifier)%>, challengeInput));
      return type.Property({
        predicate: Not,
        inputs: [type.Property({
          predicate: <%= innerProperty.dec.isCompiled ? "address(this)" : innerProperty.dec.predicate %>,
          inputs: [<%=getInputs(innerProperty)%>]
        })]
      });
      <% } else if(property.statement.predicate == 'Not') {
        const innerProperty = property.statement.compiledChildren[0];
        %>
      return type.Property({
        predicate: <%= innerProperty.dec.originalPredicateName %>,
        inputs: [property.inputs[<%= innerProperty.dec.inputs[0] %>]]
      });
      <% } %>
    }
  <% } %>
  function decideTrue<%= property.dec.predicate %>(bytes[] memory _inputs) public {
      bytes32 propertyHash = keccak256(abi.encode(types.Property({
        predicate: address(this),
        inputs: _inputs
      })));
      // check property is true
    <% if(property.statement.predicate == 'And') { %>
      // check And
      <%
        for(var j = 0;j < property.statement.compiledChildren.length;j++) {
          var item = property.statement.compiledChildren[j]
      %>
      require(AdjudicationContract.isDecided(keccak256(abi.encode({
          predicate: <%= item.dec.originalPredicateName %>,
          inputs: [<%= getInputs(item, "witness") %>]
        }))));
      <% } %>
      AdjudicationContract.setPredicateDecision(propertyHash, true);
    <% } else if(property.statement.predicate == 'ThereExistsSuchThat') { %>
      // check ThereExistsSuchThat
      <%
        const quantifier = property.statement.compiledChildren[0]
        const innerProperty = property.statement.compiledChildren[2]
      %>
      require(<%= quantifier.dec.predicate %>.decide(<%= getInputs(quantifier, "witness") %>, witness));
      require(AdjudicationContract.isDecided(keccak256(abi.encode({
        predicate: <%= innerProperty.dec.originalPredicateName %>,
        inputs: [<%= getInputs(innerProperty, "witness") %>]
      }))));
      AdjudicationContract.setPredicateDecision(propertyHash, true);
    <% } else if(property.statement.predicate == 'Or') { %>
      // check Or
    var result = false
      <%
        for(var j = 0;j < property.statement.compiledChildren.length;j++) {
          var item = property.statement.compiledChildren[j]
      %>
    result = result | AdjudicationContract.isDecided(keccak256(abi.encode({
        predicate: <%= item.dec.originalPredicateName %>,
        inputs: [<%= getInputs(item) %>]
      })))
      <% } %>
    require(result);
    AdjudicationContract.setPredicateDecision(propertyHash, true);
    <% } %>
  }
  <% } %>
}
