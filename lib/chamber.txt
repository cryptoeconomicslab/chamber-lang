// OVM language grammar
// ==========================
//

{

}

Program
  = Declation*

Declation
  = "def" _ dec:Decider _ ":=" _ s:Statement _ {
    return {
      dec: dec,
      statement: s
    }
  }

Statement
  = expr:Expression tail:(Expression)*

Predicate
  = UniversalQuantifier / ThereExistsQuantifier / NotPredicate / Decider

NoArgs
  = "(" _ ")" {
    return []
  }

ArgsExist
  = "(" arg:Arg args:("," _ Arg)* ")" {
    return [arg].concat(args.map((a) => a[2]))
  }

Args
  = ArgsExist / NoArgs

Arg
  = Object / String

Decider
  = name:String _ args:Args {
  return {
    predicate: name,
    input: args
  }
}
  
UniversalQuantifier
  = "for" _ v:String _ "in" _ V:Decider _ "{" _ property:Expression _ "}" {
    return {
      predicate: "ForAllSuchThat",
      inputs: [
        V,
        v,
        property
      ]
    }
  }

ThereExistsQuantifier
  = "with" _ Q:Decider _ "as" _ v:String _ "{" _ property:Expression _ "}" {
    return {
      predicate: "ThereExistsSuchThat",
      inputs: [
        Q,
        v,
        property
      ]
    }
  }

NotPredicate
  = "!" _ property:Expression {
    return {
      predicate: "Not",
      inputs: [
        property
      ]
    }
  }

Expression
  = head:Factor tail:(_ ("and" / "or") _ Factor)* {
      if(tail.length > 0) {
        return {
          predicate: tail[0][1],
          input: [head, tail[0][3]]
        }
      } else {
        return head;
      }
    }

Factor
  = "(" _ expr:Expression _ ")" { return expr; }
  / Predicate

Integer "integer"
  = _ [0-9]+ { return parseInt(text(), 10); }

Object
  = parent:String "." child:String {
    return {
      syntax: "bind",
      parent: parent,
      child: child
    }
  }

String "string"
  = _ [a-zA-Z_]+ { return text(); }

_ "whitespace"
  =  [ \\t\\n\\r]*
